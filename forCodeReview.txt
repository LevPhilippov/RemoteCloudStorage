Серверная часть (CloudStorageServer)
package com.filippov;


public class MainServer {
    public static void main(String[] args) {
        new Server().run();
    }
}


public class Server {
    ChannelFuture channelFuture;

    public void run() {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {

            @Override
            protected void initChannel(SocketChannel socketChannel) throws Exception {
                socketChannel.pipeline().addLast(
                        new LoggingHandler("serverLog", LogLevel.INFO),
                        new ObjectEncoder(),
                        new ObjectDecoder(1024*1024*10,ClassResolvers.cacheDisabled(null)),
                        new ObjectInboundHandler());
            }
            }).childOption(ChannelOption.SO_KEEPALIVE,true);

            channelFuture = bootstrap.bind("127.0.0.1", 8189);

            channelFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture channelFuture) throws Exception {
                    System.out.println("Сервер запущен на порту " + channelFuture.channel().localAddress().toString());
                }
            }).sync();

            channelFuture.channel().closeFuture().sync();

        } catch (InterruptedException e) {
            e.printStackTrace();
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
}

public class ObjectInboundHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            if (msg instanceof Request) {
                Request request = (Request) msg;
                if(request.getRequestType().equals(Request.RequestType.ANSWER)) {
                    System.out.println("Получен ответ!");
                    ctx.fireChannelRead(request);
                    return;
                }

                System.out.println("Получен запрос! Отправляю в парсер запросов!");
                RequestHandler.parse((Request)msg, ctx);
            }
            else {
                CloudWrappedObject cwo = (CloudWrappedObject) msg;
                System.out.println(cwo.getMsg());
                System.out.println("Отправляю в парсер объектов!");
                CWOHandler.parse(cwo);
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }
}

Клиентская часть (CloudStorageClient):

package com.filippov;


@Getter
public class Controller implements Initializable {

    @FXML
    private ListView serverListView;

    @FXML
    private ListView localListView;

    @FXML
    private TextField serverFolder;

    @FXML
    private TextField clientFolder;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        try {
            Class.forName("com.filippov.Network");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        localListView.setManaged(true);
        serverListView.setManaged(true);
        localListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        serverListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        refreshLocalFileList(Network.getInstance().getPathHolder().getClientPath());
        setListenersOnListView();
    }

    private void setListenersOnListView() {
        localListView.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                if(event.getClickCount()==2) {
                    PathHolder pathHolder = Network.getInstance().getPathHolder();
                    String path = pathHolder.getClientPath() + '/' + (String)localListView.getSelectionModel().getSelectedItem();
                    if(Files.isDirectory(Paths.get(path))) {
                        System.out.println("Новый путь к директории клиента: " + path);
                        refreshLocalFileList(path);
                        return;
                    }
                    System.out.println("Выбранный файл не является директорией!");
                }
            }
        });

        serverListView.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                if(event.getClickCount()==2) {
                    PathHolder pathHolder = Network.getInstance().getPathHolder();
                    String path = pathHolder.getServerPath() + '/' + (String)serverListView.getSelectionModel().getSelectedItem();
                    System.out.println("Запрашиваю список файлов сервера в каталоге: " + path);
                    Network.getInstance().requestFilesList(path);
                }
            }
        });
    }

    public void refreshLocalFileList(String path) {
        if (Platform.isFxApplicationThread()) {
            Network.getInstance().getPathHolder().setClientPath(path);
            localListView.getItems().clear();
            Factory.giveFileList(path).stream().forEach(localListView.getItems()::add);
        } else {
            Platform.runLater(() -> {
                Network.getInstance().getPathHolder().setClientPath(path);
                localListView.getItems().clear();
                Factory.giveFileList(path).stream().forEach(localListView.getItems()::add);
            });
        }
        clientFolder.setText(Network.getInstance().getPathHolder().getClientPath());
    }

    public void push() {
        ObservableList <String> os = localListView.getSelectionModel().getSelectedItems();
        Network.getInstance().sendFileToCloud(os);
    }

    public void connect() {
        Network.setController(this);
        Network.getInstance().startNetwork();
    }

    public void disconnest() {
        Platform.runLater(() -> Network.getInstance().shutdown());
        Platform.exit();
    }

    public void refreshServerFileList(List<String> serverFileList) {
        if (Platform.isFxApplicationThread()) {
                serverListView.getItems().clear();
                serverFileList.stream().forEach(serverListView.getItems()::add);
                serverFolder.setText(Network.getInstance().getPathHolder().getServerPath());

        } else {
            Platform.runLater(() -> {
                    serverListView.getItems().clear();
                    serverFileList.stream().forEach(serverListView.getItems()::add);
                    serverFolder.setText(Network.getInstance().getPathHolder().getServerPath());
            });
        }

    }

    public void requestFile() {
        ObservableList<String> os = serverListView.getSelectionModel().getSelectedItems();
        Network.getInstance().requestFile(os);
    }

    public void stepBackServerPath(){
        String newPath = Factory.giveStepBackPath(Network.getInstance().getPathHolder().getServerPath());
        Network.getInstance().requestFilesList(newPath);
    }

    public void stepBackClientPath(){
        String newPath = Factory.giveStepBackPath(Network.getInstance().getPathHolder().getClientPath());
        refreshLocalFileList(newPath);
    }
}

package com.filippov;

import com.filippov.Handlers.ClientAnswerHandler;
import com.filippov.Handlers.ObjectInboundHandler;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.codec.serialization.ObjectEncoder;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import javafx.collections.ObservableList;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

package com.filippov;

import com.filippov.Handlers.ClientAnswerHandler;
import com.filippov.Handlers.ObjectInboundHandler;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.codec.serialization.ObjectEncoder;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import javafx.collections.ObservableList;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class Network{
    private static Network ourInstance = new Network();
    public static Network getInstance() {return ourInstance;}
    private Network(){}
    private static PathHolder pathHolder = new PathHolder();;
    private ChannelFuture cf;
    private EventLoopGroup bossGroup;
    private Bootstrap bootstrap;
    private static Controller controller;

    public void startNetwork() {
        bossGroup = new NioEventLoopGroup(2);
        bootstrap = new Bootstrap();
        Thread networkThread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    bootstrap.group(bossGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new LoggingHandler("EndLogger", LogLevel.INFO),
                                    new ObjectDecoder(1024*1024*10,ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new ObjectInboundHandler(),
                                    new ClientAnswerHandler()
                            );
                        }
                    }).option(ChannelOption.SO_KEEPALIVE, true);

                    cf = bootstrap.connect("127.0.0.1", 8189);
                    cf.addListener((ChannelFutureListener) channelFuture -> {
                        if(!channelFuture.isSuccess()) {
                            System.out.println("Connnection failed!");
                        } else {
                            System.out.println("Connection success!");
                            requestFilesList(pathHolder.getServerPath());
                        }

                    }).sync();
                    cf.channel().closeFuture().sync();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    shutdown();
                }
            }
        });
        networkThread.setDaemon(true);
        networkThread.start();
    }

    public ChannelFuture getCf() {
        return cf;
    }

    public void shutdown() {
        cf.channel().closeFuture();
        bossGroup.shutdownGracefully();
    }

    /**
     * Принимает на вход список имен файлов в директории, где находится клиент выполняет запись этих файлов в канал
     * */
    public void sendFileToCloud(ObservableList<String> os) {
            os.stream().map((s) -> Paths.get(pathHolder.getClientPath() + "/" + s)).forEach(consumer);
//        requestFilesList(pathHolder.getServerPath());
    }

    public Controller getController() {
        return controller;
    }

    public static void setController(Controller controller) {
        Network.controller = controller;
    }

    /**
    * Метод отправляет запрос {@link Request} к серверу на получение списка файлов в указанной дидектории на сервере
     * @param path локальный адрес на сервере
     * */

    public void requestFilesList(String path) {
        System.out.println("Запрашиваю список файлов в каталоге " + path);
        cf.channel().writeAndFlush(new Request().setRequestType(Request.RequestType.FILELIST).setServerPath(path));
    }

    public void requestFile(ObservableList<String> os) {
        List <String> filesList = new ArrayList<>();
        filesList.addAll(os);
        System.out.println("Запрос файлов из облака " + filesList);
        cf.channel().writeAndFlush(new Request()
                .setRequestType(Request.RequestType.GETFILES)
                .setServerPath(pathHolder.getServerPath())
                .setFileList(filesList)
                .setClientPath(pathHolder.getClientPath()));
    }

    public PathHolder getPathHolder() {
        return pathHolder;
    }


    Consumer<Path> consumer = p -> {

            if (Files.exists(p)) {
                    try {
                        Files.walkFileTree(p, new FileVisitor<Path>() {
                            @Override
                            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                                pathHolder.setClientPath(dir.toString());
                                pathHolder.setServerPath(pathHolder.getServerPath() + "/" + dir.getFileName().toString());
                                System.out.println("Зашли в директорию на клиенте: "+ pathHolder.getClientPath());
                                System.out.println("Зашли в директорию на сервере: " + pathHolder.getServerPath());
                                return FileVisitResult.CONTINUE;
                            }

                            @Override
                            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                                writeIntoChannel(file);
                                return FileVisitResult.CONTINUE;
                            }

                            @Override
                            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                                System.out.println("Ошибка отправки файла");
                                return null;
                            }

                            @Override
                            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                                String clientPath = pathHolder.getClientPath();
                                System.out.println("Путь перед выходом:" + clientPath);
                                pathHolder.setClientPath(Factory.giveStepBackPath(clientPath));
                                pathHolder.setServerPath(Factory.giveStepBackPath(pathHolder.getServerPath()));
                                System.out.println("Вышли из дериктории клиента: "+ pathHolder.getClientPath());
                                System.out.println("Вышли из директории сервера: " + pathHolder.getServerPath());
                                return FileVisitResult.CONTINUE;                            }
                        });
                    } catch (IOException e) {
                        e.printStackTrace();
                    }


                }
        System.out.println("В конце директория клиента: " + pathHolder.getClientPath());
        System.out.println("В конце директория сервера: " + pathHolder.getServerPath());
    };

    private void writeIntoChannel(Path path) {
        System.out.printf("Файл %s будет записан в канал и размещен в папке %s на сервере", path.getFileName().toString(), pathHolder.getServerPath());
        System.out.println();
//        try {
//            CloudWrappedObject cwo = CloudWrappedObject.wrapFile(path, pathHolder.getClientPath(), pathHolder.getServerPath());
//            cf.channel().writeAndFlush(cwo).addListener((ChannelFutureListener) channelFuture -> {
//                System.out.println("Writing Complete!");
//                requestFilesList(pathHolder.getServerPath());
//            });
//        } catch (IOException a) {
//            System.out.println("Ошибка записи");
//            a.printStackTrace();
//        }
    }



}

public class PathHolder {

    private final String clientRootPath = "CloudStorageClientV2/Storage";
    private final String serverRootPath = "CloudStorageServer/Storage";
    private String clientPath;
    private String serverPath;

    public PathHolder() {
        this.clientPath = clientRootPath;
        this.serverPath = serverRootPath;
//        System.out.println(clientPath);
//        System.out.println(clientRootPath);
    }

    public String getClientPath() {
        return clientPath;
    }

    public void setClientPath(String clientPath) {
        this.clientPath = clientPath;
    }

    public String getServerPath() {
        return serverPath;
    }

    public void setServerPath(String serverPath) {
        this.serverPath = serverPath;
    }
}

package com.filippov.Handlers;



public class ObjectInboundHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            if (msg instanceof Request) {
                Request request = (Request) msg;
                if(request.getRequestType().equals(Request.RequestType.ANSWER)) {
                    System.out.println("Получен ответ!");
                    ctx.fireChannelRead(request);
                    return;
                }
                System.out.println("Получен запрос! Отправляю в парсер запросов!");
                RequestHandler.parse((Request)msg, ctx);
            }
            else {
                CloudWrappedObject cwo = (CloudWrappedObject) msg;
                System.out.println(cwo.getMsg());
                System.out.println("Отправляю в парсер объектов!");
                CWOHandler.parse(cwo);
            }
        } finally {
            Network.getInstance().getController().refreshLocalFileList(Network.getInstance().getPathHolder().getClientPath());
            ReferenceCountUtil.release(msg);
        }
    }
}

package com.filippov.Handlers;


public class ClientAnswerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            Request request = (Request) msg;
            switch (request.getAnswerType()) {
                case FILELIST: {
                    System.out.println("Обновляю список файлов на сервере " + request.getFileList() );
                    Network.getInstance().getPathHolder().setServerPath(request.getServerPath());
                    Network.getInstance().getController().refreshServerFileList(request.getFileList());
                    break;
                }
                default: {
                    System.out.println("Неизвестный ответ");
                    break;
                }
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }
}


Общие классы (CloudObjectCommonFiles):


@Getter
@Setter
public class CloudWrappedObject implements Serializable {

    private TypeEnum typeEnum;
    private byte[] bytes;
    private long hashSum;
    private int parcelNumber;
    private int parcelsInObject;
    private String fileName;
    private String localPath;
    private String baseTargetPath;
    private String msg;

    public CloudWrappedObject(TypeEnum typeEnum, byte[] bytes, String fileName, String localPath, String baseTargetPath) {
        this.typeEnum = typeEnum;
        this.bytes = bytes;
        this.fileName = fileName;
        this.localPath = localPath;
        this.baseTargetPath = baseTargetPath;
    }

    public enum TypeEnum {
        FILE, SEPARATEDFILE
    }

    public static CloudWrappedObject wrapFile(Path path, String localPath, String baseTargetPath) throws IOException {
        System.out.println("-----------------------------");
        System.out.printf("Wrapping object %s in directory %s into %s Server Folder: ", path.getFileName().toString(), localPath, baseTargetPath);

        byte[] bytes = null;
//        if (Files.exists(path)) {
        bytes = Files.readAllBytes(path);
//        }
        CloudWrappedObject cwo = new CloudWrappedObject(CloudWrappedObject.TypeEnum.FILE, bytes, path.getFileName().toString(), localPath, baseTargetPath);
        System.out.println("Байтов прочитано " + bytes.length);
        return cwo;
    }

}


public class CWOHandler {

    public static void parse(CloudWrappedObject cwo) {
        switch (cwo.getTypeEnum()) {
            case FILE: writeIntoFile(cwo); break;
            default: showError(); break;
        }
    }

    private static void showError() {
        System.out.println("Неизвестная команда или данные повреждены");
    }


    private static void writeIntoFile(CloudWrappedObject cwo) {
        System.out.println("ЦВО Парсер");
        String baseTargetPath = cwo.getTargetPath();
        Path path = Paths.get(baseTargetPath + "/" + cwo.getFileName());
        System.out.println(path.toString());

        if(!Files.exists(path)){
            try {
                Files.createDirectories(Paths.get(baseTargetPath));
                Files.createFile(path);
                Files.write(path,cwo.getBytes());
            } catch (IOException e) {
                System.out.println("Не удалось записать файл!");
                e.printStackTrace();
            }
        } else {
            System.out.println("Файл уже существует");
        }
    }


public class Factory {

    public static List<String> giveFileList(String path) {
        List<String> fileList = new ArrayList<>();
        try {
            Files.walk(Paths.get(path),1).forEach(p -> {
                fileList.add(p.getFileName().toString());
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
        return fileList;
    }

    public static String giveStepBackPath(String oldPath) {
        System.out.println("Меняю старый путь: " + oldPath);
        String[] oldPathArray = oldPath.split("/");
        String[] newPathArray = Arrays.copyOfRange(oldPathArray,0,oldPathArray.length-1);
        StringBuilder builder = new StringBuilder();
        Arrays.stream(newPathArray).forEach((s)-> {
            builder.append(s + '/');
        });
        String newPath = builder.toString();
        System.out.println("Новый путь: " + newPath);
        return newPath;
    }
}



@Getter
public class Request implements Serializable {

    public enum RequestType {
        ANSWER, AUTH, FILELIST, GETFILES, ECHO, DELETEFILES;
    }

    private RequestType requestType;
    private RequestType answerType;
    private String serverPath;
    private String clientPath;
    private List<String> fileList;

    public Request setRequestType(Request.RequestType requestType){
        this.requestType = requestType;
        return this;
    }

    public Request setAnswerType(Request.RequestType answerType) {
        this.answerType=answerType;
        return this;
    }

    public Request setServerPath(String serverPath) {
        this.serverPath = serverPath;
        return this;
    }
    public Request setClientPath(String clientPath) {
        this.clientPath = clientPath;
        return this;
    }

    public Request setFileList (List<String> fileList) {
        this.fileList = fileList;
        return this;
    }
}




public class RequestHandler {

    public static void parse(Request request, ChannelHandlerContext ctx) {
        switch (request.getRequestType()){
            case FILELIST: sendFileList(request,ctx);
                break;
            case GETFILES: writeFilesIntoCTX(request, ctx);
                break;
            default:
                System.out.println("Неизвестный тип Request");
                break;
        }
    }

    /**
     * Метод выдергивает из {@link Request} адрес каталога и отправляет список файлов в этом каталоге.
     * При указании файла вместо каталога ничего не отправляется.
     * */
    public static void sendFileList(Request request, ChannelHandlerContext ctx) {
        String path= "CloudStorageServer/Storage";
        if(request.getServerPath() == null || request.getServerPath().equals("root")) {
            System.out.println("Получен запрос на отправку списка файлов в корневом каталоге.");
        } else {path = request.getServerPath();}
        if (Files.isDirectory(Paths.get(path))){
            List<String> fileList = Factory.giveFileList(path);
            ctx.writeAndFlush(request.setRequestType(Request.RequestType.ANSWER).setAnswerType(Request.RequestType.FILELIST).setFileList(fileList).setServerPath(path));
            System.out.println("Отправлен список файлов в каталоге " + path);
        }
        System.out.println("Запрошенный путь не является каталогом");
    }


    public static void writeFilesIntoCTX(Request request, ChannelHandlerContext ctx) {
        String serverPath = request.getServerPath();
        String clientPath = request.getClientPath();
        List<String> filesList = request.getFileList();
        System.out.println("Получен запрос на отправку файлов: " + filesList);
        filesList.stream().map((s) -> Paths.get(serverPath + File.separator + s)).forEach(path -> {
            if(Files.exists(path)) {
                System.out.println("Файл " + path.toString() + "существует");
                System.out.println(path.getFileName().toString());
                CloudWrappedObject cwo = null;
                try {
                    cwo = CloudWrappedObject.wrapFile(path,serverPath,clientPath);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                ctx.writeAndFlush(cwo).addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture channelFuture) throws Exception {
                        System.out.println("Writing Complete!");
                    }
                });
            }
        });
    }
}




